/*******************************************************************************
 * Copyright 2013-2016 Thomas Schreiber
 * Copyright 2013-2016 Rundfunk und Telekom Regulierungs-GmbH (RTR-GmbH)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package at.rtr.rmbt.statisticServer.opendata;


import at.rtr.rmbt.shared.cache.CacheHelper;
import at.rtr.rmbt.statisticServer.ServerResource;
import at.rtr.rmbt.statisticServer.opendata.dao.OpenTestDAO;
import at.rtr.rmbt.statisticServer.opendata.dto.OpenTestDTO;
import at.rtr.rmbt.statisticServer.opendata.dto.OpenTestSearchDTO;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.SequenceWriter;
import com.fasterxml.jackson.dataformat.csv.CsvGenerator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.github.sett4.dataformat.xlsx.XlsxMapper;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.json.JSONException;
import org.json.JSONObject;
import org.restlet.data.*;
import org.restlet.representation.OutputRepresentation;
import org.restlet.representation.Representation;
import org.restlet.representation.StringRepresentation;
import org.restlet.resource.Get;
import org.restlet.resource.Post;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Api(value="/opentests/search")
public class OpenTestSearchResource extends ServerResource
{
    private enum FieldType {STRING, DATE, LONG, DOUBLE, BOOLEAN, UUID, SORTBY, SORTORDER, IGNORE};

    private static final int CACHE_EXP = 3600;
    private static final String CSV_FILENAME = "opentests.csv";
    private static final String XLSX_FILENAME = "opentests.xlsx";

    private final CacheHelper cache = CacheHelper.getInstance();

    public final int MAXROWS = 10000;  //maximum number of rows allowed, currently approx 1.5s response time at maximum
    public final int DEFAULTROWS = 100; //default number of rows (when max_results is not specified)
    public final int MAXQUERYFIELDS = 50; //to prevent database-server overload


      //all fields that should be displayed in a general request (e.g. all tests for one user)
    private final String[] openDataFieldsSummary = {"open_uuid", "open_test_uuid", "time", "lat", "long", "download_kbit", "upload_kbit",
        "ping_ms", "signal_strength", "lte_rsrp",  "platform", "provider_name", "model", "loc_accuracy"};

    //all fields that are numbers (and are formatted as numbers in json)
    private final HashSet<String> openDataNumberFields = new HashSet<>(Arrays.asList(new String[]{"time", "lat", "long", "download_kbit",
        "upload_kbit","ping_ms","signal_strength", "lte_rsrp", "test_duration","num_threads","ndt_download_kbit","ndt_upload_kbit","asn","loc_accuracy"}));

    //all fields for which the user can sort the result
    private final HashSet<String> openDataFieldsSortable = new HashSet<>(Arrays.asList(new String[]{"download_kbit","upload_kbit","time","signal_strength","ping_ms"}));

    //additional fields that the user is allowed to request
    private final HashSet<String> allowedAdditionalFields = new HashSet<>(Arrays.asList(new String[] {"download_classification","upload_classification","ping_classification","signal_classification"}));



    @Get
    @Post
    @GET
    @Path("/opentests/search")
    @ApiOperation(httpMethod = "GET",
            value = "Search for open data tests",
            response = OpenTestSearchDTO.class,
            nickname = "search",
    notes = "Date fields have to be submitted as a number, representing the number of milliseconds that have elapsed since midnight, January 1st, 1970 or " +
            "in the format “yyyy-MM-dd HH:mm:ss”. The time is given in UTC.\n\n" +
            "Decimal point (Full Stop “.”) is always used to separate the integer part from the fractional part of a number written in decimal form. " +
            "This is independent from the local or regional settings.\n\n" +
            "Numeric fields also allow using the comparators ‘>’ and ‘<’ (meaning ‘=>’ and ‘=<’ respectively). Dates have always to be queried as ranges " +
            "by using these comparators.\n\n" +
            "String fields allow using the wildcard ‘*’ for matching any literals and ‘?’ for matching one arbitrary literal.\n\n" +
            "It is possible, to begin each filter argument with an exclamation mark (!) to negate the filter. E.g. network_type=!LAN will yield all " +
            "tests where the network type was not LAN.\n\n" +
            "The criteria denoted with [] can be used more than once in a query. Data has to match all criteria. If an array for one criterion is given, " +
            "the data has to match each entry.\n\n" +
            "Generally a query on a parameter value ‘null’ is not possible, except for the parameter loc_accuracy, where the value -1 means ‘null’. " +
            "Non-‘null’ values are queried with any single or multiple values.")
    @ApiImplicitParams({
            @ApiImplicitParam(name = "download_kbit", value = "Download speed in kilobit per second", dataType = "string", example = ">6903", paramType = "query"),
            @ApiImplicitParam(name = "upload_kbit", value = "Upload speed in kilobit per second.", dataType = "string", example = "<4670", paramType = "query"),
            @ApiImplicitParam(name = "ping_ms", value = "Median ping (round-trip time) in milliseconds, measured on the server side. In previous versions " +
                    "(before June 3rd 2015) this was the minimum ping measured on the client side.", dataType = "string", example = "<16", paramType = "query"),
            @ApiImplicitParam(name = "gkz", value = "Community ID (Gemeindekennzahl, see <http://www.bev.gv.at/portal/page?_pageid=713,2601287&_dad=portal&_schema=PORTAL>).", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "gkz_sa", value = "Community ID (Gemeindekennzahl, see <http://www.statistik.at/web_de/klassifikationen/regionale_gliederungen/gemeinden/index.html>)", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "cat_technology", value = "Technology category of the network, e.g. “3G”, “4G”, “WLAN”.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "client_version", value = "Software version number of the client.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "model", value = "Name of the device used.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "network_name", value = "Display name of the mobile network.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "network_type", value = "Type of the network, e.g. MOBILE, LAN, WLAN.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "platform", value = "Platform on which the test has been conducted", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "signal_strength", value = "Signal strength (RSSI) in dBm.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "lte_rsrp", value = "LTE signal strength in dBm.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "open_uuid", value = "Open-UUID: Identifies the client that conducted the test. The a new Open-UUID is assigned to the client on a regular basis.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "open_test_uuid", value = "The UUID of the test.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "client_uuid", value = "The private UUID of a client", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "loop_uuid", value = "The loop UUID of a single loop test", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "test_uuid", value = "The private UUID of a test", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "long", value = "Longitude of the client position.", dataType = "number", paramType = "query"),
            @ApiImplicitParam(name = "lat", value = "Latitude of the client position.", dataType = "number", paramType = "query"),
            @ApiImplicitParam(name = "radius", value = "Radius in meters defining based on lat/long parameters", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "mobile_provider_name", value = "mobile operator name", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "provider_name", value = "Name of the internet service provider.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "sim_mcc_mnc", value = "Network identification of the SIM provider. The digits of MCC and MNC have the same meaning as described in “network_mcc_mnc”.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "sim_country", value = "Home country of the SIM card in ISO 3166.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "network_country", value = "Country of the network in ISO 3166.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "country_geoip", value = "Country according client IP address.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "country_location", value = "Country of geo-location.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "user_server_selection", value = "Legacy", dataType = "boolean", paramType = "query"),
            @ApiImplicitParam(name = "loc_accuracy", value = "Estimation of accuracy of client location in meters", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "public_ip_as_name", value = "Name of the AS of the clients public IP.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "time", value = "UTC date and time when test was started.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "radio_band", value = "Radio band used when conducting the test.", dataType = "long", paramType = "query"),
            @ApiImplicitParam(name = "cell_area_code", value = "Number describing the coarse location of a cell. E.g. the Tracking Area Code (TAC) in case of 4G " +
                    "or the Location Area Code (LAC) in case of 2G or 3G", dataType = "long", paramType = "query"),
            @ApiImplicitParam(name = "cell_location_id", value = "Number identifying the location of a cell. E.g. the 28-bit Cell Identity (CI) in case of 4G, " +
                    "the 28-bit UMTS Cell Identity (CID) in case of UMTS or the 16-bit GSM Cell Identity (CID) in case of GSM.", dataType = "long", paramType = "query"),
            @ApiImplicitParam(name = "additional_info", value = "additional properties to return", example = "download_classification", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "format", value="Desired output format, either 'csv' or 'json', default: json", example = "json", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "sort_by", value="The field for which the data are sorted. Valid fields are: “download_kbit\", \"upload_kbit\", \"time\", \"signal_strength\", \"lte_rsrp\" and \"ping_ms\"",
                    example = "download_kbit", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "sort_order", value="The sort_by-Parameter specifies the field, the sort_order-Parameter specifies the direction ('asc' or 'desc').\n " +
                    "Per Default, the results are sorted by the time of the test in descending order (i.e. sort_by=time&sort_order=desc).\n " +
                    "If the sort parameters are specified, the value of the cursor is a multiple of the parameter max_results, otherwise it is an arbitrary number.", example = "asc", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "max_results", value="This is the page size, i.e. maximum number of result items that are returned per page.\n " +
                    "The default value is 100 items per page. The page size limit is 10000 items, i.e. not more than 10000 results can be displayed in a page.", example = "10", dataType = "integer", paramType = "query"),
            @ApiImplicitParam(name = "cursor", value = "used for pagination if the query returns more than the number of items according to parameter max_results. " +
                    "The value to be used for the display of the next page is given by the previous response in returned parameter next_cursor.", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "sender", value = "Sender ID", dataType = "string", paramType = "query"),
            @ApiImplicitParam(name = "timestamp", value = "Alias '_'. Will be ignored and can be used to prevent caching of the response.", dataType = "string", paramType = "query")
    })
    public Representation request(final Representation entity) throws JSONException {
        addAllowOrigin();

        final JSONObject response = new JSONObject();
        final Form getParameters;
        if (getRequest().getMethod().equals(Method.POST)) {
            // HTTP POST
            getParameters = new Form(entity);
        }
        else {
            // HTTP GET
            getParameters = getRequest().getResourceRef().getQueryAsForm();
        }

        final QueryParser qp = new QueryParser();

        final Set<String> additionalFields;
        final List<String> invalidElements = qp.parseQuery(getParameters);
        OpenTestSearchDTO ret = new OpenTestSearchDTO();


        //calculate offset
        long offset = -1;
        if (getParameters.getNames().contains("cursor")) {
            //is always a valid LONG because it is checked with all other
            //parameters above
            offset = Long.parseLong(getParameters.getFirstValue("cursor"));
        }

        //get maximal results-parameter
        long maxrows = DEFAULTROWS;
        if (getParameters.getNames().contains("max_results")) {
            //is always a valid LONG because it is checked with all other
            //parameters above
            maxrows = Long.parseLong(getParameters.getFirstValue("max_results"));
        }

        //parse additional fields
        if (getParameters.getNames().contains("additional_info") || getParameters.getNames().contains("additional_info[]")) {
            String param = (getParameters.getNames().contains("additional_info")) ? "additional_info" : "additional_info[]";
            for (String field : getParameters.getValuesArray(param)) {
                if (!allowedAdditionalFields.contains(field)) {
                    invalidElements.add(param);
                }
            }
            additionalFields = new HashSet<>(Arrays.asList(getParameters.getValuesArray(param)));
        } else {
            additionalFields = new HashSet<>();
        }

        String format = getParameters.getFirstValue("format", "json").toLowerCase();;

        //if there have been errors => inform the user
        if (invalidElements.size() > 0) {
            setStatus(Status.CLIENT_ERROR_BAD_REQUEST);
            response.put("invalid_fields", invalidElements);
            ret.getInvalidFields().addAll(invalidElements);
        }

        //if there are too many query elements (DoS-Attack?), don't let it
        //get to the database
        else if (qp.getWhereParams().keySet().size() > MAXQUERYFIELDS) {
            setStatus(Status.CLIENT_ERROR_BAD_REQUEST);
            ret.getInvalidFields().add("field limit exceeded");
        }
        else {
            //if valid input, query the db
            OpenTestDAO dao = new OpenTestDAO(conn, settings, capabilities);
            ret = dao.getOpenTestSearchResults(qp, offset, maxrows, additionalFields);
        }

        Representation representation = null;

        //format, depending on output format
        try {
            if (format.equals("csv")) {
                CsvMapper cm = new CsvMapper();
                cm.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                cm.enable(CsvGenerator.Feature.STRICT_CHECK_FOR_QUOTING);
                CsvSchema schema = CsvSchema.builder().setLineSeparator("\r\n").setUseHeader(true)
                        .addColumnsFrom(cm.schemaFor(OpenTestDTO.class)).build();
                representation = new StringRepresentation(cm.writer(schema).writeValueAsString(ret.getResults()));
            }
            else if (format.equals("xlsx")) {
                final OpenTestSearchDTO that = ret;
                OutputRepresentation or = new OutputRepresentation(MediaType.APPLICATION_MSOFFICE_XLSX) {
                    @Override
                    public void write(OutputStream outputStream) throws IOException {
                        XlsxMapper mapper = new XlsxMapper();
                        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                        CsvSchema schema = mapper.schemaFor(OpenTestDTO.class).withHeader();
                        SequenceWriter sequenceWriter = mapper.writer(schema).writeValues(outputStream);
                        sequenceWriter.writeAll(that.getResults());
                        sequenceWriter.flush();
                        sequenceWriter.close();
                    }
                };
                representation = or;
            }
            else {
                ObjectMapper om = new ObjectMapper();
                om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                representation = new StringRepresentation(om.writer().writeValueAsString(ret));
            }
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            setStatus(Status.SERVER_ERROR_INTERNAL);
        }

        if (format.equals("csv")) {
            Disposition disposition = new Disposition(Disposition.TYPE_ATTACHMENT);
            disposition.setFilename(CSV_FILENAME);
            representation.setMediaType(MediaType.TEXT_CSV);
            representation.setDisposition(disposition);
            representation.setCharacterSet(CharacterSet.UTF_8);
        }
        else if (format.equals("xlsx")) {
            Disposition disposition = new Disposition(Disposition.TYPE_ATTACHMENT);
            disposition.setFilename(XLSX_FILENAME);
            representation.setMediaType(MediaType.APPLICATION_MSOFFICE_XLSX);
            representation.setDisposition(disposition);
        }
        else {
            representation.setMediaType(MediaType.APPLICATION_JSON);
            representation.setCharacterSet(CharacterSet.UTF_8);
        }

        return representation;
    }




}

