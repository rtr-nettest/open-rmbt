package at.rtr.rmbt.statisticServer.opendata.dao;

import at.rtr.rmbt.shared.Classification;
import at.rtr.rmbt.shared.GeoAnalytics;
import at.rtr.rmbt.shared.model.SpeedItems;
import at.rtr.rmbt.shared.smoothing.Smoothable;
import at.rtr.rmbt.shared.smoothing.SmoothingFunction;
import at.rtr.rmbt.statisticServer.OpenTestResource;
import at.rtr.rmbt.statisticServer.ServerResource;
import at.rtr.rmbt.statisticServer.opendata.OpenTestSearchResource;
import at.rtr.rmbt.statisticServer.opendata.QueryParser;
import at.rtr.rmbt.statisticServer.opendata.dto.*;
import at.rtr.rmbt.util.capability.Capabilities;
import com.google.gson.Gson;
import org.apache.commons.dbutils.BasicRowProcessor;
import org.apache.commons.dbutils.GenerousBeanProcessor;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.json.JSONException;

import java.sql.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class OpenTestDAO {

    //maximum of rows sent in one single request
    public final int MAX_SEARCH_ROWS = 10000;  //maximum number of rows allowed, currently approx 1.5s response time at maximum

    /**
     * disable/enable smoothing of returned curves
     */
    public final static boolean RETURN_SMOOTHED_SPEED_CURVES = false;

    /**
     * data amount for centered moving average must not be < 3 and odd.
     * The function needs x values on the "left" and "right side" of the current value, where x = (SMOOTHING_DATA_AMOUNT-1)/2
     * f(i) = 1/x * (e[i-x] + e[i-x+1] + ... + e[i] + ... + e[i+x-1] + e[i+x])
     */
    public final static int SMOOTHING_DATA_AMOUNT = 5;


    public final int DEFAULT_SEARCH_ROWS = 100; //default number of rows (when max_results is not specified)


    private Connection conn;
    private ResourceBundle settings;
    private Capabilities capabilities;

    public OpenTestDAO (Connection conn, ResourceBundle settings, Capabilities capabilities) {
        this.settings = settings;
        this.conn = conn;
        this.capabilities = capabilities;
    }


    /**
     * Get detailled open data for a single test
     * @param openTestUUID
     * @param verboseLevel
     * @return
     */
    public OpenTestDetailsDTO getSingleOpenTestDetails(String openTestUUID, int verboseLevel) {
        final String sql = "SELECT t.uid as test_uid, " +
                " ('P' || t.open_uuid) open_uuid," +  //csv 1:open_uuid, UUID prefixed with 'P'
                " ('O' || t.open_test_uuid) open_test_uuid," + //csv  open_test_uuid, UUID prefixed with 'O'
                " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
                " t.time full_time," + //csv: 3:time server time-stamp of start of measurement
                " t.client_time client_time," +  //(internal) client time-stamp of start of measure
                " t.network_group_name cat_technology," + //csv 4:cat_technology
                " t.network_group_type network_type," + //csv 5:network_type
                /*
                " t.geo_lat lat," + //csv 6:lat
                " t.geo_long long," + // csv 7:long
                " t.geo_provider loc_src," + //csv 8:loc_src android: 'gps'/'network'; browser/iOS: '' (empty string)
                " t.geo_accuracy loc_accuracy, " + //accuracy of geo location in m
                */
                //csv 6:lat
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " tl.geo_lat" +
                " WHEN (tl.geo_accuracy < ?) THEN" +
                " ROUND(tl.geo_lat*1111)/1111" + // approx 100m
                " ELSE null" +
                " END) latitude," +
                // csv 7:long
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " tl.geo_long" +
                " WHEN (tl.geo_accuracy < ?) THEN" +
                " ROUND(tl.geo_long*741)/741 " + //approx 100m
                " ELSE null" +
                " END) longitude," +
                // csv 8:loc_src android: 'gps'/'network'; browser/iOS: '' (empty string)
                " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
                " 'rastered'" + //make raster transparent
                " ELSE tl.geo_provider" +
                " END) loc_src," +
                // accuracy of geo location in m
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
                " THEN tl.geo_accuracy " +
                " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
                " WHEN (tl.geo_accuracy < ?) THEN tl.geo_accuracy" +
                " ELSE null END) loc_accuracy, " +
                " NULL zip_code," +
                " tl.kg_nr_bev kg_nr," +
                " tl.gkz_bev gkz," +
                " tl.gkz_sa gkz_sa," +
                " tl.land_cover land_cover," +
                " k.kg locality," +
                " k.pg community," +
                " k.pb district," +
                " k.bl province," +
                " NULL cov800cat," +
                " t.speed_download download_kbit," + //csv 10:download_kbit
                " t.speed_upload upload_kbit," + //csv 11: upload_kbit
                " t.wifi_link_speed," + // nominal speed of wifi-link in mbit/s , Android-only
                " (t.ping_median::float / 1000000) ping_ms," + //median ping-time in ms (stored in ns in data base)
                " signal_strength," + //csv 13:signal_strength RSSI, mainly GSM/UMTS and Wifi, Android only, in dBm
                " lte_rsrp," + // csv 29: signal_strength RSRP, Android only, in dBm
                " lte_rsrq," + // signal quality RSRQ, Android only, in dB
                " ts.name server_name," + //csv 14:server_name, name of the test server used for download/upload (not applicable for JStest)
                " implausible, " +  //csv 28:implausible, measurement not shown in map nor used in statistics, normally not visible
                " pinned, " + //true, if test is used in statistics, false if it is a repeated measurement
                " public_ip_as_name, " + //name of AS (not number)
                " duration test_duration," +  //csv 15:test_duration, nominal duration of downlink and uplink throughput tests in seconds
                " num_threads_requested," + // number of threads requested by control-server
                " num_threads," + //csv 16:num_threads, number of threads used in downlink throughput test (uplink may differ)
                " num_threads_ul," + // number of threads used in uplink test
                " COALESCE(t.plattform, t.client_name) as platform," + //csv 17:platform; currently used: 'CLI'/'Android'/Applet/iOS/[from client_name: RMBTws, RMBTjs](null); (null) is used for RMBTjs
                " COALESCE(adm.fullname, t.model) model," + //csv 18:model, translated t.model (model_native) to human readable form
                " t.model model_native," + //device used for test; Android API 'model'; iOS:'product'; Browser: Browser-name (zB Firefox)
                " t.product product," +  // product used for test; Android APO 'product'; iOS: '' (not used); Browser: same as for model (browser name)
                " t.client_software_version client_version," + //csv 19:client_version, SW-version of client software (not RMBT-client-version), eg. '1.3'
                " t.network_operator network_mcc_mnc," + //csv 20:network_mcc_mnc, mobile country and network code of current network (Android only), string, eg "232-12'
                " network_country," + //(internal) Android-only, country code derived by client from mobile network code
                // " network_is_roaming," + //(internal) roaming-status of mobile network, boolean or (null); Android-only (obsolete)
                " roaming_type," + //roaming-status of mobile network, integer: 0:not roaming,1:national,2:international,(null):unknown (eg. iOS)
                " t.network_operator_name network_name," + //csv 21:network_name, name of current mobile network as displayed on device (eg: '3likeHome')
                " t.network_sim_operator sim_mcc_mnc," + //csv 22:sim_mcc_mnc, home network of SIM (initial 5 digits from IMSI), eg '232-01'
                " t.network_sim_country sim_country," + //(internal) Android-only, country derived by client from SIM (country of home network)
                " COALESCE(mprov.name,msim.shortname,msim.name,prov.name) provider_name," +  //pre-defined list of providers (based on provider_id) //TODO replace provider
                " t.nat_type \"connection\"," + //csv 23:connection, translation-mechanism in NAT, eg. nat_local_to_public_ipv4
                " t.public_ip_asn asn," + //csv 24:asn, AS (autonomous system) number, number of public IP network
                " t.client_public_ip_anonymized ip_anonym," +  //csv 25:ip_anonym, anonymized IP of client (IPv4: 8 bits removed, IPv6: 72 bits removed)
                " (ndt.s2cspd*1000)::int ndt_download_kbit," + //csv 26:ndt_download_kbit, result of NDT downlink throughput test kbit/s
                " (ndt.c2sspd*1000)::int ndt_upload_kbit," + //csv 27 ndt_uoload_kbit, result of NDT uplink throughput test in kbit/s
                " country_geoip," + // country-code derived from public IP-address, eg. 'AT'
                " tl.country_location country_location," + // country-code derived from geo_location, eg. 'DE'
                " country_asn," + // country_code derived from AS, eg. 'EU'
                " bytes_download," + // number of bytes downloaded during test (download and upload) (obsolete)
                " bytes_upload," + // number of bytes uploaded during test (download and upload) (obsolete)
                " test_if_bytes_download," + //downloaded bytes on interface during total test (inc. training, ping, without NDT) (obsolete)
                " test_if_bytes_upload," + //uploaded bytes on interface during total test (inc. training, ping, without NDT) (obsolete)
                " testdl_if_bytes_download," + //downloaded bytes on interface during download-test (without training-seq)
                " testdl_if_bytes_upload," + //uploaded bytes on interface during download-test (without training-seq)
                " testul_if_bytes_download," + //downloaded bytes on interface during upload-test (without training-seq)
                " testul_if_bytes_upload," + //downloaded bytes on interface during upload-test (without training-seq)
                " (t.nsec_download::float / 1000000) duration_download_ms," + //duration of download-test in ms
                " (t.nsec_upload::float / 1000000) duration_upload_ms," + //duration of upload-test in ms
                " (t.time_dl_ns::float / 1000000) time_dl_ms," + //relative start time of download-test in ms (ignoring training-phase)
                " (t.time_ul_ns::float / 1000000) time_ul_ms," + //relative start time of download-test in ms (ignoring training-phase)
                // " phone_type" + //(internal) radio type of phone: 0 no mobile radio, 1 GSM (incl. UMTS,LTE) 2 CDMA (obsolete)
                " speed.items speed_items," + // json representation of individual up+down speed items
                " channel_number," +
                " radio_band," +
                " cell_location_id," +
                " cell_area_code," +
                " tl.settlement_type settlement_type" +
                " , tl.link_id link_id" +
                " , tl.link_name link_name" +
                " , tl.link_distance link_distance" +
                " , tl.edge_id::bigint edge_id" +
                " , tl.frc link_frc" +
                " , tl.dtm_level dtm_level" +
                " , ln.name1 link_name1" +
                " , ln.name2 link_name2" +
                " FROM test t" +
                " LEFT JOIN device_map adm ON adm.codename=t.model" +
                " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
                " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
                " LEFT JOIN provider prov ON t.provider_id=prov.uid" +
                " LEFT JOIN provider mprov ON t.mobile_provider_id=mprov.uid" +
                " LEFT JOIN mccmnc2name msim ON t.mobile_sim_id=msim.uid" +
                " LEFT JOIN speed ON speed.open_test_uuid=t.open_test_uuid" +
                " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
                " LEFT JOIN bev_vgd k ON tl.kg_nr_bev = k.kg_nr_int" +
                " LEFT JOIN linknet ln on tl.link_id = ln.link_id " +
                " WHERE " +
                " t.deleted = false " +
                " AND t.status = 'FINISHED' " +
                " AND t.open_test_uuid = ? ";


        //System.out.println(sql);

        OpenTestDetailsDTO dto = new OpenTestDetailsDTO();

        final String[] columns;
        PreparedStatement ps = null;
        ResultSet rs = null;

        try
        {
            ps = conn.prepareStatement(sql);

            //insert filter for accuracy
            double accuracy = Double.parseDouble(settings.getString("RMBT_GEO_ACCURACY_DETAIL_LIMIT"));
            ps.setDouble(1, accuracy);
            ps.setDouble(2, accuracy);
            ps.setDouble(3, accuracy);
            ps.setDouble(4, accuracy);
            ps.setDouble(5, accuracy);
            ps.setDouble(6, accuracy);


            //openTestIDs are starting with "O"
            if (openTestUUID != null && openTestUUID.startsWith("O")) {
                openTestUUID = openTestUUID.substring(1);
            }
            ps.setObject(7, openTestUUID, Types.OTHER);

            if (!ps.execute())
                return null;
            rs = ps.getResultSet();

            BeanHandler<OpenTestDetailsDTO> handler = new BeanHandler<>(OpenTestDetailsDTO.class,new BasicRowProcessor(new GenerousBeanProcessor()));
            dto = handler.handle(rs);

            if (dto != null)
            {
                //classify download, upload, ping, signal
                dto.setDownloadClassification(Classification.classify(Classification.THRESHOLD_DOWNLOAD, dto.getDownloadKbit(), capabilities.getClassificationCapability().getCount()));
                dto.setUploadClassification(Classification.classify(Classification.THRESHOLD_UPLOAD, dto.getUploadKbit(), capabilities.getClassificationCapability().getCount()));
                dto.setPingClassification(Classification.classify(Classification.THRESHOLD_PING, Math.round(dto.getPingMs() * 1000000), capabilities.getClassificationCapability().getCount()));

                //classify signal accordingly
                if ((dto.getSignalStrength() != null || dto.getLteRsrp() != null)
                        && dto.getNetworkType() != null) { // signal available
                    if (dto.getLteRsrp() == null) { // use RSSI
                        if (dto.getNetworkType().equals("WLAN")) { // RSSI for Wifi
                            dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_WIFI, dto.getSignalStrength(), capabilities.getClassificationCapability().getCount()));
                        } else { // RSSI for Mobile
                            dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_MOBILE, dto.getSignalStrength(), capabilities.getClassificationCapability().getCount()));
                        }
                    } else // RSRP for LTE
                        dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_RSRP,dto.getLteRsrp(), capabilities.getClassificationCapability().getCount()));
                } else { // no signal available
                    dto.setSignalClassification(null);
                }


                //also load download/upload-speed-data, signal data and location data if possible

                // speed data
                final Gson gson = ServerResource.getGson(false);
                final SpeedItems speedItems = gson.fromJson(rs.getString("speed_items"), SpeedItems.class);

                //graphs
                OpenTestGraphDTO graphs = new OpenTestGraphDTO();

                if (speedItems != null)
                {
                    long lastTime = -1;
                    final List<SpeedItems.SpeedItem> uploadList = speedItems.getAccumulatedSpeedItemsUpload();
                    //System.out.println(uploadList.size());
                    final List<SpeedItems.SpeedItem> downloadList = speedItems.getAccumulatedSpeedItemsDownload();
                    //System.out.println(downloadList.size());
                    List<SpeedGraphItemDTO> downloadSpeeds = new ArrayList<>();
                    List<SpeedGraphItemDTO> uploadSpeeds = new ArrayList<>();

                    if (!RETURN_SMOOTHED_SPEED_CURVES) {
                        SpeedGraphItemDTO obj;
                        for (SpeedItems.SpeedItem item : uploadList) {
                            obj = new SpeedGraphItemDTO();
                            final long time = Math.round((double) item.getTime() / 1e6);
                            if (time == lastTime)
                                continue;
                            obj.setTimeElapsed(item.getTime());
                            obj.setBytesTotal(item.getBytes());
                            uploadSpeeds.add(obj);
                            lastTime = time;
                        }
                        lastTime = -1;
                        for (SpeedItems.SpeedItem item : downloadList) {
                            obj = new SpeedGraphItemDTO();
                            final long time = Math.round((double) item.getTime() / 1e6);
                            if (time == lastTime)
                                continue;
                            obj.setTimeElapsed(item.getTime());
                            obj.setBytesTotal(item.getBytes());
                            downloadSpeeds.add(obj);
                            lastTime = time;
                        }
                    }
                    else {
                        final List<? extends Smoothable> smoothedUploadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, uploadList, SMOOTHING_DATA_AMOUNT);
                        final List<? extends Smoothable> smoothedDownloadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, downloadList, SMOOTHING_DATA_AMOUNT);

                        lastTime = -1;

                        SpeedGraphItemDTO obj;
                        for (Smoothable item : smoothedUploadList) {
                            obj = new SpeedGraphItemDTO();
                            final long time = Math.round((double) item.getXValue() / 1000000);
                            if (time == lastTime)
                                continue;
                            obj.setTimeElapsed(time);
                            obj.setBytesTotal(item.getYValue());
                            uploadSpeeds.add(obj);
                        }

                        lastTime = -1;

                        for (Smoothable item : smoothedDownloadList) {
                            obj = new SpeedGraphItemDTO();
                            final long time = Math.round((double) item.getXValue() / 1e6);
                            if (time == lastTime)
                                continue;
                            obj.setTimeElapsed(time);
                            obj.setBytesTotal(item.getYValue());
                            downloadSpeeds.add(obj);
                        }
                    }

                    graphs.setDownload(downloadSpeeds);
                    graphs.setUpload(uploadSpeeds);
                }

                //if verbose - also add raw json data
                if (speedItems != null && verboseLevel > 0) {
                    Map<String, Map<Integer, List<SpeedItems.SpeedItem>>> rawJSON = speedItems.getRawJSONData();

                    //threads
                    Map<String, Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>>> threadwise = new HashMap<>();

                    //phases
                    for (String phase : rawJSON.keySet()) {

                        Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>> threads = new HashMap<>();
                        threadwise.put(phase, threads);

                        for (int thread : rawJSON.get(phase).keySet()) {
                            List<SpeedGraphItemDTO.SpeedItemThreadwise> threadItems = new ArrayList<>();
                            threads.put(String.valueOf(thread),threadItems);

                            //speed items
                            for (SpeedItems.SpeedItem item : rawJSON.get(phase).get(thread)) {
                                SpeedGraphItemDTO.SpeedItemThreadwise measurement = new SpeedGraphItemDTO.SpeedItemThreadwise();
                                measurement.setBytesTotal(item.getBytes());
                                measurement.setTimeElapsed(item.getTime());
                                threadItems.add(measurement);
                            }
                        }
                    }

                    dto.setSpeedCurveThreadwise(threadwise);
                }

                //Ping
                List<PingGraphItemDTO> pingGraph = getPingGraph(UUID.fromString(openTestUUID), conn);
                graphs.setPing(pingGraph);

                //Load signal strength from database
                List<SignalGraphItemDTO> radioSignalGraph = getRadioSignalGraph(rs.getLong("test_uid"), UUID.fromString(rs.getObject("open_test_uuid").toString().substring(1)), rs.getTimestamp("client_time").getTime(), conn);
                graphs.setSignal(radioSignalGraph);

                //Load gps coordinates from database
                LocationGraphDTO locGraph = getLocationGraph(rs.getLong("test_uid"),  rs.getTimestamp("client_time").getTime(), conn);
                graphs.setLocation(locGraph.getLocations());

                dto.setSpeedCurve(graphs);

                //get movement during test
                GeoAnalytics.TestDistance dist = new GeoAnalytics.TestDistance(UUID.fromString(openTestUUID), conn);
                if ((dist != null) && (dist.getTotalDistance() > 0) &&
                        dist.getTotalDistance() <= Double.parseDouble(settings.getString("RMBT_GEO_DISTANCE_DETAIL_LIMIT"))) {
                    dto.setDistance(dist.getTotalDistance());
                }

            } else {
                //invalid open_uuid
                //setStatus(Status.CLIENT_ERROR_NOT_FOUND);
                if (dto == null) {
                    dto = new OpenTestDetailsDTO();
                }
                dto.setError("invalid open-uuid");
            }
        }
        catch (SQLException ex) {
            //setStatus(Status.CLIENT_ERROR_NOT_FOUND);
            if (dto == null) {
                dto = new OpenTestDetailsDTO();
            }
            dto.setError("invalid open-uuid");

            Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, ex);
        }
        finally
        {
            try
            {
                if (rs != null)
                    rs.close();
                if (ps != null)
                    ps.close();
            }
            catch (final SQLException e)
            {
                Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, e);
            }
        }

        return dto;
    }

    /**
     * Calculate the rough distance in meters between two points
     * taken from http://stackoverflow.com/questions/120283/working-with-latitude-longitude-values-in-java
     * @param lat1
     * @param lng1
     * @param lat2
     * @param lng2
     * @return
     */
    private static double distFrom(double lat1, double lng1, double lat2, double lng2) {
        double earthRadius =  6371000;
        double dLat = Math.toRadians(lat2-lat1);
        double dLng = Math.toRadians(lng2-lng1);
        double sindLat = Math.sin(dLat / 2);
        double sindLng = Math.sin(dLng / 2);
        double a = Math.pow(sindLat, 2) + Math.pow(sindLng, 2)
                * Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2));
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        double dist = earthRadius * c;

        return dist;
    }

    private LocationGraphDTO getLocationGraph(long testUID, long testTime, java.sql.Connection conn) throws SQLException {
        PreparedStatement psLocation = conn.prepareStatement("SELECT test_id, g.geo_lat latitude, g.geo_long longitude, g.accuracy loc_accuracy, g.bearing bearing, g.speed speed, g.provider provider, altitude, time "
                + " FROM geo_location g "
                + " WHERE g.test_id = ? and accuracy < " + settings.getString("RMBT_GEO_ACCURACY_DETAIL_LIMIT")
                + " ORDER BY time;");
        psLocation.setLong(1, testUID);
        ResultSet rs = psLocation.executeQuery();

        boolean first = true;
        LocationGraphDTO.LocationGraphItem firstItem = null;

        Double lastLat = null;
        Double lastLong = null;
        double totalDistance=0;

        BeanListHandler<LocationGraphDTO.LocationGraphItem> handler = new BeanListHandler<>(LocationGraphDTO.LocationGraphItem.class, new BasicRowProcessor(new GenerousBeanProcessor()));
        List<LocationGraphDTO.LocationGraphItem> allResultList = handler.handle(rs);
        Iterator<LocationGraphDTO.LocationGraphItem> iterator = allResultList.iterator();
        List<LocationGraphDTO.LocationGraphItem> resultList = new ArrayList<>();

        while (iterator.hasNext()) {
            LocationGraphDTO.LocationGraphItem item = iterator.next();
            long timeElapsed = item.getTime().getTime() - testTime;
            item.setTimeElapsed(timeElapsed);

            //there could be measurements taken before a test started
            //in this case, only return the last one
            if (item != null && timeElapsed < 0) {
                lastLat = item.getLatitude();
                lastLong = item.getLongitude();
                item.setTimeElapsed(0);
                firstItem = item;
            }
            //put triplet in the array if it is not the first one
            else {
                //first item > 0 - add item previously stored for later consumption
                if (firstItem != null) {
                    resultList.add(firstItem);
                    firstItem = null;
                }

                //only put the point in the resulting array, if there is a significant
                //distance from the last point
                //therefore (difference in m) > (tolerance last point + tolerance new point)
                if (lastLat != null && lastLong != null) {
                    double diff = distFrom(lastLat, lastLong, item.getLatitude(), item.getLongitude());
                    totalDistance += diff;
                }

                resultList.add(item);
                lastLat = item.getLatitude();
                lastLong = item.getLongitude();
            }
        }

        //if no item was with time > 0 - add the last one here
        if (firstItem != null) {
            resultList.add(firstItem);
        }

        LocationGraphDTO lg = new LocationGraphDTO();
        lg.setLocations(resultList);
        lg.setTotalDistance(totalDistance);

        psLocation.close();
        return lg;
    }

    private List<PingGraphItemDTO> getPingGraph(UUID openTestUuid, java.sql.Connection conn) throws SQLException {
        PreparedStatement psPing = conn.prepareStatement("SELECT (value_server/1e6)::float ping_ms, (time_ns/1e6)::bigint time_elapsed FROM  ping WHERE open_test_uuid = ?");
        psPing.setObject(1, openTestUuid);

        BeanListHandler<PingGraphItemDTO> handler = new BeanListHandler<>(PingGraphItemDTO.class,new BasicRowProcessor(new GenerousBeanProcessor()));
        List<PingGraphItemDTO> pingList = handler.handle(psPing.executeQuery());
        psPing.close();

        return pingList;
    }


    private static List<SignalGraphItemDTO> getRadioSignalGraph(long testUID, UUID openTestUuid, long testTime, java.sql.Connection conn) throws SQLException {
        final int LOWER_BOUND = -1500;
        final int MAX_TIME = 60000;

        boolean additionalInformation = true;
        PreparedStatement psSignal = conn.prepareStatement("SELECT radio_cell.open_test_uuid, radio_cell.mnc, radio_cell.mcc, radio_cell.location_id, radio_cell.area_code, " +
                "radio_cell.primary_scrambling_code, radio_cell.channel_number, " +
                "nt.name network_type, technology cat_technology, signal_strength, lte_rsrp, lte_rsrq, signal_strength wifi_rssi, timing_advance, time " +
                "FROM radio_cell " +
                "JOIN radio_signal ON radio_signal.cell_uuid = radio_cell.uuid " +
                "JOIN network_type nt ON nt.uid = network_type_id " +
                "WHERE radio_signal.open_test_uuid = ? " +
                "AND radio_cell.active = TRUE AND (radio_cell.primary_data_subscription = 'true' OR radio_cell.primary_data_subscription IS NULL) " +
                "  ORDER BY radio_signal.time;");
        psSignal.setObject(1, openTestUuid);

        ResultSet rsSignal = psSignal.executeQuery();

        //if there are no results -> try using the old tables that may be available for some measurements
        if (!rsSignal.isBeforeFirst()) {
            psSignal.close();
            additionalInformation = false;

            psSignal = conn.prepareStatement("SELECT test_id, nt.name network_type, nt.group_name cat_technology, signal_strength, lte_rsrp, lte_rsrq, wifi_rssi, time "
                    + "FROM signal "
                    + "JOIN network_type nt "
                    + "ON nt.uid = network_type_id "
                    + "WHERE open_test_uuid = ? "
                    + "ORDER BY time;");
            psSignal.setObject(1, openTestUuid);

            rsSignal = psSignal.executeQuery();

        }

        boolean first = true;
        SignalGraphItemDTO item = null;
        List<SignalGraphItemDTO> signalList = new ArrayList<>();
        while (rsSignal.next()) {
            long timeElapsed = rsSignal.getTimestamp("time").getTime() - testTime;
            //there could be measurements taken before a test started
            //in this case, only return the last one
            if (first && timeElapsed > 0 && item != null) {
                signalList.add(item);
                first = false;
            }

            //ignore measurements after a threshold of one minute
            if (timeElapsed > MAX_TIME)
                break;


            Integer signalStrength = rsSignal.getInt("signal_strength");
            int lteRsrp = rsSignal.getInt("lte_rsrp");
            int lteRsrq = rsSignal.getInt("lte_rsrq");
            if (signalStrength == 0) {
                signalStrength = rsSignal.getInt("wifi_rssi");
            }

            if ((signalStrength != 0 && signalStrength > LOWER_BOUND) || lteRsrp > LOWER_BOUND || lteRsrq > LOWER_BOUND) {
                if (additionalInformation) {
                    int channelNumber = rsSignal.getInt("channel_number");
                    item = new SignalGraphItemDTO();
                    item.setTimeElapsed(Math.max(timeElapsed,0));

                    item = new SignalGraphItemDTO(Math.max(timeElapsed, 0), rsSignal.getString("network_type"), signalStrength, lteRsrp, lteRsrq, rsSignal.getString("cat_technology"),
                            rsSignal.getInt("location_id"), rsSignal.getInt("area_code"), rsSignal.getInt("primary_scrambling_code"), channelNumber, rsSignal.getObject("timing_advance", Integer.class));
                }
                else {
                    item = new SignalGraphItemDTO(Math.max(timeElapsed, 0), rsSignal.getString("network_type"), signalStrength, lteRsrp, lteRsrq, rsSignal.getString("cat_technology"));
                }
            }


            //put 5-let in the array if it is not the first one
            if (!first || rsSignal.isLast()) {
                if (timeElapsed < 0) {
                    item.setTimeElapsed(1000);
                }
                signalList.add(item);
            }
        }

        rsSignal.close();
        psSignal.close();
        return signalList;
    }


    /**
     * Get search results for a given query, containing some open data fields
     * @param qp the queryParse-object
     * @param offset a offset-value for paging (given as "next-cursor" in the response), -1 if none is set
     * @param maxrows maximal count of rows returned
     * @param additionalFields additional fields that should be included in the response
     * @return
     */
    public OpenTestSearchDTO getOpenTestSearchResults(QueryParser qp, long offset, long maxrows, Set<String> additionalFields) {
        long startTime = System.currentTimeMillis();
        OpenTestSearchDTO dto = new OpenTestSearchDTO();

        String offsetString = (offset>0)? " AND t.uid<"+offset:""; //if no sorting is used
        String offsetString2 = (offset>0)? " OFFSET "+offset:""; //if sorting is used => may have concurrency issues in the results

        String orderClause = qp.getOrderClause();
        boolean defaultOrder = true;
        if (orderClause == null || orderClause.isEmpty()) {
            orderClause = " ORDER BY t.uid DESC ";
            offsetString2 = "";
        } else {
            defaultOrder = false;
            offsetString = "";
        }

        if (maxrows> MAX_SEARCH_ROWS)
            maxrows = MAX_SEARCH_ROWS;
        if (maxrows <= 0)
            maxrows = DEFAULT_SEARCH_ROWS;


        //There are many LEFT JOINs in the sql statement that are usual not needed.
        //This has no significant impact on the performance since our DBMS (postgres)
        //is intelligent enough to ignore these during query optimization if they are
        //not needed
        final String sql = "SELECT" +
                " t.uid as cursor, " + //only for pagination
                " ('P' || t.open_uuid) open_uuid," +
                " ('O' || t.open_test_uuid) open_test_uuid," +
                " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
                //" nt.group_name cat_technology," +
                //" nt.name network_type," +

                //csv 6:lat
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " t.geo_lat" +
                " WHEN (t.geo_accuracy < ?) THEN" +
                " ROUND(t.geo_lat*1111)/1111" + // approx 100m
                " ELSE null" +
                " END) latitude," +
                // csv 7:long
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " t.geo_long" +
                " WHEN (t.geo_accuracy < ?) THEN" +
                " ROUND(t.geo_long*741)/741 " + //approx 100m
                " ELSE null" +
                " END) longitude," +
                // accuracy of geo location in m
                " (CASE WHEN (t.geo_accuracy < ?) AND (t.geo_provider IS DISTINCT FROM 'manual') AND (t.geo_provider IS DISTINCT FROM 'geocoder') " +
                " THEN t.geo_accuracy " +
                " WHEN (t.geo_accuracy < 100) AND ((t.geo_provider = 'manual') OR (t.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
                " WHEN (t.geo_accuracy < ?) THEN t.geo_accuracy" +
                " ELSE null END) loc_accuracy, " +
                //" t.geo_provider loc_src," +
                " t.speed_download download_kbit," +
                " t.speed_upload upload_kbit," +
                " (t.ping_median::float / 1000000) ping_ms," +
                " t.signal_strength," +
                " t.lte_rsrp," +
                //" ts.name server_name," +
                //" duration test_duration," +
                //" num_threads," +
                " CONCAT(plattform,' ',network_group_name) as platform, " +
                " network_group_name cat_technology," +
                " COALESCE(adm.fullname, t.model) model," +
                " COALESCE(mprov.shortname, t.network_operator_name, prov.shortname, msim.shortname,msim.name,"
                + "    prov.name, mprov.name, t.public_ip_as_name, network_sim_operator) provider_name " +
                //" client_software_version client_version," +
                //" network_operator network_mcc_mnc," +
                //" network_operator_name network_name," +
                //" network_sim_operator sim_mcc_mnc," +
                //" nat_type \"connection\"," +
                //" public_ip_asn asn," +
                //" client_public_ip_anonymized ip_anonym," +
                //" (ndt.s2cspd*1000)::int ndt_download_kbit," +
                //" (ndt.c2sspd*1000)::int ndt_upload_kbit" +
                " FROM test t" +
                qp.getJoins() +
                " WHERE " +
                " (t.deleted = false)" +
                " AND status = 'FINISHED' " + qp.getWhereClause("AND") + offsetString +
                orderClause + " LIMIT " + maxrows + offsetString2;


        PreparedStatement ps = null;
        ResultSet rs = null;
        try
        {
            ps = conn.prepareStatement(sql);

            //don't show coordinates when not accurate enough
            double accuracy = Double.parseDouble(settings.getString("RMBT_GEO_ACCURACY_DETAIL_LIMIT"));
            ps.setDouble(1, accuracy);
            ps.setDouble(2, accuracy);
            ps.setDouble(3, accuracy);
            ps.setDouble(4, accuracy);
            ps.setDouble(5, accuracy);
            ps.setDouble(6, accuracy);

            //fill in values for WHERE
            //ps = fillInWhereClause(ps, searchValues, 1);
            qp.fillInWhereClause(ps, 7);

            if (!ps.execute())
                return null;
            rs = ps.getResultSet();

            BeanListHandler<OpenTestDTO> handler = new BeanListHandler<>(OpenTestDTO.class,new BasicRowProcessor(new GenerousBeanProcessor()));
            List<OpenTestDTO> results = handler.handle(rs);

            dto.setResults(results);

            //remember last uid for pagination since rs can only be traversed in one direction
            //if there are more results than we send, use pagination
            if (dto.getResults().size() == maxrows) {
                //if it is the standard sort order
                if (defaultOrder) {
                    dto.setNextCursor(results.get(results.size() - 1).getCursor());
                } else {
                    offset = (offset<0) ? 0 : offset;
                    dto.setNextCursor(offset + maxrows);
                }
            } else {
                dto.setNextCursor(null);
            }

            //also put in the result, how long the query took to execute
            long elapsedTime = System.currentTimeMillis() - startTime;
            //jsonResponse.put("duration_ms",elapsedTime);
            dto.setDurationMs(elapsedTime);

            if (additionalFields != null) {
                for (OpenTestDTO result : dto.getResults()) {
                    if (additionalFields.contains("download_classification")) {
                        result.setDownloadClassification(Classification.classify(Classification.THRESHOLD_DOWNLOAD, result.getDownloadKbit(), 4));
                    }
                    if (additionalFields.contains("upload_classification")) {
                        result.setUploadClassification(Classification.classify(Classification.THRESHOLD_UPLOAD, result.getUploadKbit(), 4));
                    }
                    if (additionalFields.contains("ping_classification")) {
                        result.setPingClassification(Classification.classify(Classification.THRESHOLD_PING, Math.round(result.getPingMs() * 1000000), 4));
                    }
                    if (additionalFields.contains("signal_classification") && (result.getSignalStrength() != null || result.getLteRsrp() != null)) {
                        if (result.getPlatform().contains("WLAN") ) { // RSSI for Wifi
                            result.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_WIFI, result.getSignalStrength(), 4));
                        } else if (result.getLteRsrp() != null) {
                            result.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_RSRP,result.getLteRsrp(), 4));
                        }
                        else { // RSSI for Mobile
                            result.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_MOBILE, result.getSignalStrength(), 4));
                        }
                    }
                }
            }

        }
        catch (SQLException ex) {
            try {
                //setStatus(Status.CLIENT_ERROR_NOT_FOUND);
            } catch (JSONException ex1) {
                Logger.getLogger(OpenTestSearchResource.class.getName()).log(Level.SEVERE, null, ex1);
            }
            Logger.getLogger(OpenTestSearchResource.class.getName()).log(Level.SEVERE, null, ex);
        }
        finally
        {
            try
            {
                if (rs != null)
                    rs.close();
                if (ps != null)
                    ps.close();
            }
            catch (final SQLException e)
            {
                Logger.getLogger(OpenTestSearchResource.class.getName()).log(Level.SEVERE, null, e);
            }
        }
        return dto;
    }

    /**
     * Get a list of open data test results fro a given time with mid-level details
     * @param hoursExport true, if export should be done for hours
     * @param dateExport true, if export should be done for a given date
     * @param year
     * @param month
     * @param hours get tests of the last X hours
     * @return
     */
    public List<OpenTestExportDTO> getOpenTestExport(boolean hoursExport, boolean dateExport, int year, int month, int hours) {
        final String timeClause;

        if (dateExport)
            timeClause = " AND (EXTRACT (month FROM t.time AT TIME ZONE 'UTC') = " + month +
                    ") AND (EXTRACT (year FROM t.time AT TIME ZONE 'UTC') = " + year + ") ";
        else if (hoursExport)
            timeClause = " AND time > now() - interval '" + hours + " hours' ";
        else
            timeClause = " AND time > current_date - interval '31 days' ";


        final String sql = "SELECT" +
                " ('P' || t.open_uuid) open_uuid," +
                " ('O' || t.open_test_uuid) open_test_uuid," +
                " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI:SS') \"time\"," +
                " nt.group_name cat_technology," +
                " nt.name network_type," +
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " tl.geo_lat" +
                " WHEN (tl.geo_accuracy < ?) THEN" +
                " ROUND(tl.geo_lat*1111)/1111" +
                " ELSE null" +
                " END) latitude," +
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') THEN" +
                " tl.geo_long" +
                " WHEN (tl.geo_accuracy < ?) THEN" +
                " ROUND(tl.geo_long*741)/741 " +
                " ELSE null" +
                " END) longitude," +
                " (CASE WHEN ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN" +
                " 'rastered'" + //make raster transparent
                " ELSE tl.geo_provider" +
                " END) loc_src," +
                " (CASE WHEN (tl.geo_accuracy < ?) AND (tl.geo_provider IS DISTINCT FROM 'manual') AND (tl.geo_provider IS DISTINCT FROM 'geocoder') " +
                " THEN round(tl.geo_accuracy::float * 10)/10 " +
                " WHEN (tl.geo_accuracy < 100) AND ((tl.geo_provider = 'manual') OR (tl.geo_provider = 'geocoder')) THEN 100" + // limit accuracy to 100m
                " WHEN (tl.geo_accuracy < ?) THEN round(tl.geo_accuracy::float * 10)/10" +
                " ELSE null END) loc_accuracy, " +
                " tl.gkz_bev gkz," +
                " NULL zip_code," +
                " tl.country_location country_location," +
                " t.speed_download download_kbit," +
                " t.speed_upload upload_kbit," +
                " round(t.ping_median::float / 100000)/10 ping_ms," +
                " t.lte_rsrp," +
                " t.lte_rsrq," +
                " ts.name server_name," +
                " duration test_duration," +
                " num_threads," +
                " t.plattform platform," +
                " COALESCE(adm.fullname, t.model) model," +
                " client_software_version client_version," +
                " network_operator network_mcc_mnc," +
                " network_operator_name network_name," +
                " network_sim_operator sim_mcc_mnc," +
                " nat_type," +
                " public_ip_asn asn," +
                " client_public_ip_anonymized ip_anonym," +
                " (ndt.s2cspd*1000)::int ndt_download_kbit," +
                " (ndt.c2sspd*1000)::int ndt_upload_kbit," +
                " COALESCE(t.implausible, false) implausible," +
                " t.signal_strength," +
                " t.pinned pinned," +
                " tl.kg_nr_bev kg_nr," +
                " tl.gkz_sa gkz_sa," +
                " tl.land_cover, " +
                " t.cell_location_id," +
                " t.cell_area_code," +
                " t.channel_number channel_number," +
                " t.radio_band radio_band" +
                " , tl.settlement_type settlement_type" +
                " , tl.link_id link_id" +
                " , tl.link_name link_name" +
                " , tl.link_distance link_distance" +
                " , tl.edge_id::bigint edge_id" +
                " , tl.frc link_frc" +
                " , tl.dtm_level dtm_level" +
                " FROM test t" +
                " LEFT JOIN network_type nt ON nt.uid=t.network_type" +
                " LEFT JOIN device_map adm ON adm.codename=t.model" +
                " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
                " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
                " LEFT JOIN test_location tl on t.open_test_uuid = tl.open_test_uuid" +
                " WHERE " +
                " t.deleted = false" +
                timeClause +
                " AND status = 'FINISHED'" +
                " ORDER BY t.uid";

        final String[] columns;
        final List<String[]> data = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;

        final List<OpenTestExportDTO> results;
        try
        {
            ps = conn.prepareStatement(sql);

            //insert filter for accuracy
            double accuracy = Double.parseDouble(settings.getString("RMBT_GEO_ACCURACY_DETAIL_LIMIT"));
            ps.setDouble(1, accuracy);
            ps.setDouble(2, accuracy);
            ps.setDouble(3, accuracy);
            ps.setDouble(4, accuracy);
            ps.setDouble(5, accuracy);
            ps.setDouble(6, accuracy);

            if (!ps.execute())
                return null;
            rs = ps.getResultSet();


            BeanListHandler<OpenTestExportDTO> handler = new BeanListHandler<>(OpenTestExportDTO.class,new BasicRowProcessor(new GenerousBeanProcessor()));
            results = handler.handle(rs);
            return results;

        }
        catch (final SQLException e)
        {
            e.printStackTrace();
            return null;
        }
        finally
        {
            try
            {
                if (rs != null)
                    rs.close();
                if (ps != null)
                    ps.close();
            }
            catch (final SQLException e)
            {
                e.printStackTrace();
            }
        }
    }
}
